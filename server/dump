#!/usr/bin/env node --harmony-weak-refs
/**
 * @license
 *
 * Copyright 2018 Google Inc.
 * https://github.com/NeilFraser/CodeCity
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview Infrastructure to save the state of an Interpreter as
 *     eval-able JS.  Mainly a wrapper around Dumper, handling
 *     the application of a dupmp configuration.
 * @author cpcallen@google.com (Christohper Allen)
 */
'use strict';

var code = require('./code');
var CodeCity = require('./codecity');
var Do = require('./dumper').Do;
var Dumper = require('./dumper').Dumper;
var Writable = require('./dumper').Writable;
var fs = require('fs');
var Interpreter = require('./interpreter');
var path = require('path');
var Selector = require('./selector');

/**
 * Dump an Interpreter using a given dump specification.
 * @param {!Interpreter} intrp The interpreter to dump.
 * @param {!Array<ConfigItem>} config The dump specification.
 * @param {string=} directory A directory relative to which
 *     non-absolute filenames in config should be written.  If none is
 *     supplied then they will be treated as relative to the current
 *     directory.
 * @param {boolean=} verbose Print message describing what is being done.
 */
var dump = function(intrp, config, directory, verbose) {
  var dumper = new Dumper(new Interpreter(), intrp, {verbose: verbose});
  if (verbose) console.log('Dumper initialised.');

  // Skip everything that's explicitly mentioned in the config, so
  // that paths won't get dumped until it's their turn.
  for (var item, i = 0; item = config[i]; i++) {
    if (!item.contents) continue;
    for (var entry, j = 0; entry = item.contents[j]; j++) {
      dumper.skip(entry.selector);
    }
  }
  // Dump the specified paths, in order.
  for (var entry, i = 0; item = config[i]; i++) {
    var filename = item.filename;
    if (verbose) console.log('Dumping to %s...', filename);
    if (directory !== undefined && !path.isAbsolute(filename)) {
      filename = path.normalize(path.join(directory, filename));
    }
    var outputStream = new SyncWriter(filename);
    dumper.setOptions({output: outputStream});
    dumper.write('////////////////////////////////////////',
                 '///////////////////////////////////////\n',
                 '// ', item.filename, '\n\n');
    if (item.contents) {
      for (var entry, j = 0; entry = item.contents[j]; j++) {
        try {
          if (verbose) console.log('Dumping: %s', entry.selector);
          dumper.unskip(entry.selector);
          dumper.dumpBinding(entry.selector, entry.do);
          dumper.write('\n');
        } catch (e) {
          dumper.warn(e.stack);
        }
      }
    } else if (item.rest) {
      if (verbose) console.log('Dumping rest.');
      // TODO(cpcallen): encapsulate this in Dumper
      /** @suppress {accessControls} */
      var globalScopeDumper = dumper.getScopeDumper_(intrp.global);
      globalScopeDumper.dump(dumper);
    }
    outputStream.end();
  }
};

/**
 * Convert a dump plan from an !Array<!SpecConfigItem> to
 * !Array<!ConfigItem>, with validataion and a few conversions:
 *
 * - Whereas as in the input, paths will will be represented by
 *   selector strings, in the corresponding output the properties will
 *   be Selectors.  The SpecConfigEntry path: will become .selector in
 *   the corresponding COnfigEntry.
 *
 * - Whereas the input will specify do: values as strings
 *   (e.g. "RECURSE"), the output will have Do enum values
 *   (e.g. Do.RECURSE) instead.
 *
 * - A plain selector string ss, appearing in the contents: array of a
 *   SpecFileItem, will be replaced by the ContentEntry
 *   {selector: new Selector(ss), do: Do.RECURSE, reorder: false}.
 *
 * - All optional boolean-valued properties will be normalised to
 *   exist, defaulting to false.
 *
 * @param {*} spec The dump plan to be validated.  If this is not an
 *     !Array<!SpecEntry>, TypeError will be thrown.
 * @return {!Array<!ConfigItem>}
 */
var configFromSpec = function(spec) {
  var /** !Array<ConfigItem> */ config = [];

  /** @type {function(string, number=)} */
  function reject(message, j) {
    var prefix = 'spec[' + i + ']';
    if (j !== undefined) prefix = prefix + '.contents[' + j + ']';
    if (message[0] !== '.') prefix = prefix + ' ';
    throw new TypeError(prefix + message);
  }

  if (!Array.isArray(spec)) {
    throw new TypeError('spec must be an array of SpecConfigItems');
  }
  for (var i = 0; i < spec.length; i++) {
    var item = spec[i];

    if (typeof item !== 'object' || item === null) {
      reject('not a SpecConfigItem object');
    }
    if ('filename' in item) {  // It's a SpecFileItem.
      var /** !Array<!ContentEntry> */ contents = [];

      if (typeof item.filename !== 'string') {
        // TODO(cpcallen): add better filename validity check?
        reject('.filename is not a string');
      } else if (!Array.isArray(item.contents) && item.contents !== undefined) {
        reject('.contents is not an array');
      } else if (typeof item.rest !== 'boolean' && item.rest !== undefined) {
        reject('.rest is not a boolean');
      } else if (item.contents) {
        for (var j = 0; j < item.contents.length; j++) {
          var entry = item.contents[j];

          if (typeof entry === 'string') {
            var selector = new Selector(entry);
            contents.push({selector: selector, do: Do.RECURSE, reorder: false});
            continue;
          } else if (typeof entry !== 'object' || entry === null) {
            reject('not a SpecContentEntry object', j);
          } else if (typeof entry.path !== 'string') {
            reject('.path not a vaid selector string', j);
          } else if (!Do.hasOwnProperty(entry.do)) {
            reject('.do: ' + entry.do + ' is not a valid Do value', j);
          } else if (typeof entry.reorder !== 'boolean' &&
                     entry.reorder !== undefined) {
            reject('.reorder must be boolean or omitted', j);
          }
          contents.push({
            selector: new Selector(entry.path),
            do: Do[entry.do],
            reorder: Boolean(entry.reorder),
          });
        }
      } else if (!item.rest) {
        throw new TypeError(
            'spec[' + i + '] must specify one of .contents or .rest');
      }
      config.push({
        filename: item.filename,
        contents: contents,  // Possibly empty.
        rest: Boolean(item.rest),
      });
    } else { // It's a SpecOptionsItem.
      var /** !Array<!Selector> */ prune = [];
      var foundOne = false;

      if ('prune' in item) {
        foundOne = true;
        if (!Array.isArray(item.prune)) {
          reject('.prune is not an  array');
        }
        for (var j = 0; j < item.prune.length; j++) {
          prune.push(new Selector(item.prune[j]));
        }
      }
      if (!foundOne) {
        reject('OptionsItem must contain one of: .prune');
      }
    } 
  }
  return config;
};

/**
 * A synchronous writable stream, with an API that is a simplified
 * subset of stream.Writable.
 * @constructor
 * @implements Writable
 * @param {string} filename The file to write to.
 */
var SyncWriter = function(filename) {
  /** @type {number|null} */
  this.fd = fs.openSync(filename, 'w', 0o600);
};

/**
 * Write string to file.
 * @override
 * @param {string} s String to write.
 * @returns {void}
 */
SyncWriter.prototype.write = function(s) {
  if (this.fd === null) throw Error('stream already ended');
  fs.writeSync(this.fd, s);
};

/**
 * Close file.
 * @returns {void}
 */
SyncWriter.prototype.end = function() {
  if (this.fd === null) throw Error('stream already ended');
  fs.closeSync(this.fd);
  this.fd = null;
};

///////////////////////////////////////////////////////////////////////////////
// Data types used to specify a dump configuration.
///////////////////////////////////////////////////////////////////////////////
// For internal use; strict types:

/**
 * A processed-and-ready-to-use configuration entry.
 * @typedef {OptionsItem|FileItem}
 */
var ConfigItem;

/**
 * A processed-and-ready-to-use configuration entry setting general
 * options.
 * @typedef {{prune: !Array<!Selector>}}
 */
var OptionsItem;

/**
 * A processed-and-ready-to-use configuration entry for a single
 * output file.
 * @typedef {{filename: string,
 *            contents: !Array<!ContentEntry>,
 *            rest: boolean}}
 */
var FileItem;

/**
 * The type of the values of .contents entries of a ConfigEntry.
 *
 * - selector: is a Selector identifying the variable or property
 *   binding this entry applies to.
 *
 * - do: is a Do value speciifying how much of selector to dump.
 *
 * - reorder: is a boolean specifying whether it is acceptable to
 *   allow property or set/map entry entries to be created (by the
 *   output JS) in a different order than they apear in the
 *   interpreter instance being serialised.  If false, output may
 *   contain placeholder entries like:
 *
 *       var obj = {};
 *       obj.foo = undefined;  // placeholder
 *       obj.bar = function() { ... };
 *
 *   to allow obj.foo to be defined later while still preserving
 *   property order.
 * 
 * @typedef {{selector: !Selector,
 *            do: Do,
 *            reorder: boolean}}
 */
var ContentEntry = function() {};

//////////////////////////////////////////////////////////////////////
// For dump_spec.json use; loose, JSON-compatible types:

/** @typedef {SpecOptionsItem|SpecFileItem} */
var SpecConfigItem;

/**
 * An OptionsItem, but with Selectors represented by selector strings.
 *
 * @typedef {{prune: !Array<string>}}
 */
var SpecOptionsItem;

/**
 * A FileItem represented as plain old JavaScript object (i.e., as
 * ouptut by JSON.parse).  Do values are reprsesented by the
 * coresponding strings (e.g., "RECURSE" instead of Do.RECURSE), while
 * content items can be just a selector string, which will be dumped
 * recursively.
 *
 * @typedef {{filename: string,
 *            contents: (!Array<string|!SpecContentEntry>|undefined),
 *            rest: (boolean|undefined)}}
 */
var SpecFileItem;

/**
 * Like a ContentEntry, but with a string instead of a Do value.
 * @typedef {{path: string,
 *            do: string,
 *            reorder: (boolean|undefined)}}
 */
var SpecContentEntry;

///////////////////////////////////////////////////////////////////////////////
// Main program.
///////////////////////////////////////////////////////////////////////////////

if (require.main === module) {
  if (process.argv.length < 4) {
    console.log(
        'usage: dump <.city file> <dump_spec.json> <output directory>');
    process.exit(1);
  }

  var cityFile = process.argv[2];
  var planFile = process.argv[3];
  var dir = process.argv[4];

  var intrp = CodeCity.loadCheckpoint(cityFile);
  var specText = fs.readFileSync(planFile);
  const spec = JSON.parse(String(specText));
  var config = configFromSpec(spec);
  dump(intrp, config, dir, /*verbose:*/ true);
};

///////////////////////////////////////////////////////////////////////////////
// Exports.
///////////////////////////////////////////////////////////////////////////////

exports.configFromSpec = configFromSpec;
exports.Do = Do;
exports.dump = dump;
